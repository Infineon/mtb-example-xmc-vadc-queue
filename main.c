/*******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: VADC QUEUE Example for
*              ModusToolbox.
*              This example shows how to convert multiple channels in a
*              dedicated sequence using the queue source. The CCU4 is used to
*              trigger the queue periodically. The ADC results will be
*              displayed on UART Terminal.
*
* Related Document: See README.md
*
********************************************************************************
*
* Copyright (c) 2015-2020, Infineon Technologies AG
* All rights reserved.
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
*******************************************************************************/
#include "cybsp.h"
#include "cy_utils.h"
#include <xmc_vadc.h>
#include <stdio.h>
#include "retarget_io.h"

/*******************************************************************************
* Data Structures
*******************************************************************************/
/* Initialization data of a VADC Global */
const XMC_VADC_GLOBAL_CONFIG_t g_global_handle = { };

/* Initialization data of a VADC Group */
const XMC_VADC_GROUP_CONFIG_t g_group_handle = { };

/* Data configuration for queue source. The trigger input A is used to
 * trigger the conversion on any edge
 */
const XMC_VADC_QUEUE_CONFIG_t g_queue_handle =
{
    .trigger_signal   = XMC_VADC_REQ_TR_A,          /* Select XMC_VADC_REQ_TR_A
                                                       trigger signal */
    .trigger_edge     = XMC_VADC_TRIGGER_EDGE_ANY,  /* Trigger edge any */
    .external_trigger = 1                           /* External trigger enabled */
};

/* Channel data configuration. Channels do NOT use alias feature and use
 * desired result registers.
 */
const XMC_VADC_CHANNEL_CONFIG_t g_g0_ch0_handle =
{
    .alias_channel     = XMC_VADC_CHANNEL_ALIAS_DISABLED, /* ALIAS is Disabled */
    .result_reg_number = 0,                               /* Result Register number */
};
const XMC_VADC_CHANNEL_CONFIG_t g_g0_ch1_handle =
{
    .alias_channel     = XMC_VADC_CHANNEL_ALIAS_DISABLED, /* ALIAS is Disabled */
    .result_reg_number = 1,                               /* Result Register number */
};
const XMC_VADC_CHANNEL_CONFIG_t g_g0_ch3_handle =
{
    .alias_channel     = XMC_VADC_CHANNEL_ALIAS_DISABLED, /* ALIAS is Disabled */
    .result_reg_number = 3,                               /* Result Register number */
};
const XMC_VADC_CHANNEL_CONFIG_t g_g0_ch5_handle =
{
    .alias_channel     = XMC_VADC_CHANNEL_ALIAS_DISABLED, /* ALIAS is Disabled */
    .result_reg_number = 5,                               /* Result Register number */
};

/* Queue entry configuration. For each entry a channel is configured. Entry
 * 1 to 3 are configured to be refilled automatically. Entry 0 and 3 can
 * be triggered externally and entry 0 generates an event after conversion.
 */
/* Queue entry configuration for channel 0 */
const XMC_VADC_QUEUE_ENTRY_t g_queue_entry_0_handle =
{
    .channel_num        = 0,  /* Channel number */
    .refill_needed      = 0,  /* Refill disabled */
    .external_trigger   = 1,  /* External trigger enabled */
    .generate_interrupt = 1,  /* Interrupt generate enabled */
};
/* Queue entry configuration for channel 3 */
const XMC_VADC_QUEUE_ENTRY_t g_queue_entry_1_handle =
{
    .channel_num        = 3,  /* Channel number */
    .refill_needed      = 1,  /* Refill enabled */
    .external_trigger   = 0,  /* External trigger disabled */
    .generate_interrupt = 0,  /* Interrupt generate disabled */
};
/* Queue entry configuration for channel 5 */
const XMC_VADC_QUEUE_ENTRY_t g_queue_entry_2_handle =
{
    .channel_num        = 5,  /* Channel number */
    .refill_needed      = 1,  /* Refill enabled */
    .external_trigger   = 0,  /* External trigger disabled */
    .generate_interrupt = 0,  /* Interrupt generate disabled */
};
/* Queue entry configuration for channel 1 */
const XMC_VADC_QUEUE_ENTRY_t g_queue_entry_3_handle =
{
    .channel_num        = 1,  /* Channel number */
    .refill_needed      = 1,  /* Refill enabled */
    .external_trigger   = 1,  /* External trigger disabled */
    .generate_interrupt = 0,  /* Interrupt generate disabled */
};

/*******************************************************************************
* Global Variable
*******************************************************************************/
XMC_VADC_RESULT_SIZE_t adc_result[16] = { 0 };

/*******************************************************************************
* Function Name: VADC0_G0_0_IRQHandler
********************************************************************************
* Summary:
* This function handles the SR0 of the Group 0.
* It is activated with XMC_VADC_GROUP_ScanInit().
*
* Parameters:
*  none
*
* Return:
*  none
*
*******************************************************************************/
void VADC0_G0_0_IRQHandler(void)
{
    /* Retrieve result from result register. */
    adc_result[0] = XMC_VADC_GROUP_GetResult(VADC_G0, 0);
    printf(" Interrupt Generated: Adc result value of channel 0: %x \r\n", adc_result[0]);
}

/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function.
* It sets up a VADC using Queue scan source.
* The Queue source is continuously requesting the conversion.
* The result is stored in the result register and read out in the while loop.
* The result values will be printed in UART Terminal.
* On board LED glows high when ADC counts are more than 2000.
*
* Parameters:
*  none
*
* Return:
*  int
*
*******************************************************************************/
int main(void)
{
    cy_rslt_t res;

    /* Initialize the device and board peripherals */
    res = cybsp_init();
    if (res != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Initialize retarget-io to use the debug UART port */
    retarget_io_init();
    printf("ADC Conversion starts \r\n");

    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(VADC, &g_global_handle);

    /* Initialize the Group */
    XMC_VADC_GROUP_Init(VADC_G0, &g_group_handle);

    /* Set VADC group to normal operation mode (VADC kernel) */
    XMC_VADC_GROUP_SetPowerMode(VADC_G0, XMC_VADC_GROUP_POWERMODE_NORMAL);

    /* Calibrate the VADC. Make sure you do this after all used VADC groups
     * are set to normal operation mode */
    XMC_VADC_GLOBAL_StartupCalibration(VADC);

    /* Initialize the queue source hardware. The gating mode is set to
     * ignore to pass external triggers unconditionally */
    XMC_VADC_GROUP_QueueInit(VADC_G0, &g_queue_handle);

    /* Initialize the channel units */
    XMC_VADC_GROUP_ChannelInit(VADC_G0, 0, &g_g0_ch0_handle);
    XMC_VADC_GROUP_ChannelInit(VADC_G0, 1, &g_g0_ch1_handle);
    XMC_VADC_GROUP_ChannelInit(VADC_G0, 3, &g_g0_ch3_handle);
    XMC_VADC_GROUP_ChannelInit(VADC_G0, 5, &g_g0_ch5_handle);

    /* Add a queue node to the tail of the queue */
    XMC_VADC_GROUP_QueueInsertChannel(VADC_G0, g_queue_entry_0_handle);
    XMC_VADC_GROUP_QueueInsertChannel(VADC_G0, g_queue_entry_1_handle);
    XMC_VADC_GROUP_QueueInsertChannel(VADC_G0, g_queue_entry_2_handle);
    XMC_VADC_GROUP_QueueInsertChannel(VADC_G0, g_queue_entry_3_handle);

    /* Start the timer counting operation */
    XMC_CCU4_SLICE_StartTimer(PWM_0_HW);

    /* Enable NVIC nodes */
    NVIC_EnableIRQ(VADC0_G0_0_IRQn);

    while (1U)
    {
        /* Retrieve result from result register. */
        adc_result[1] = XMC_VADC_GROUP_GetResult(VADC_G0, 1);
        adc_result[2] = XMC_VADC_GROUP_GetResult(VADC_G0, 3);
        adc_result[3] = XMC_VADC_GROUP_GetResult(VADC_G0, 5);

        /* Print the result values */
        printf("ADC result value of channel 1: %x, channel 3: %x and channel 5: %x \r\n", adc_result[1], adc_result[2], adc_result[3]);
    }
    return 1;
}

/* [] END OF FILE */